// vulnerabilityIndex.js - Composite vulnerability assessment combining multiple factors
// Creates holistic view of food security vulnerabilities

/**
 * Calculate comprehensive vulnerability index for food security
 * @param {Object} gridCell - Grid cell with access analysis
 * @param {Array} outlets - Food outlets in the area
 * @param {Object} climate - Climate data from NASA POWER
 * @param {Object} demographics - Optional demographic data
 * @returns {Object} Vulnerability assessment with recommendations
 */
export function calculateVulnerabilityIndex(gridCell, outlets, climate, demographics = null) {
  // Define weight factors for different vulnerability dimensions
  const weights = {
    foodAccess: 0.30,      // Current food accessibility
    economic: 0.20,        // Economic vulnerability
    climate: 0.20,         // Climate-related risks
    demographic: 0.15,     // Vulnerable populations
    infrastructure: 0.15   // Infrastructure gaps
  };

  // Calculate individual factor scores (0-1, where 1 is most vulnerable)
  const factors = {
    foodAccess: calculateFoodAccessVulnerability(gridCell),
    economic: calculateEconomicVulnerability(demographics),
    climate: calculateClimateVulnerability(climate),
    demographic: calculateDemographicVulnerability(demographics),
    infrastructure: calculateInfrastructureVulnerability(outlets, gridCell, climate)
  };

  // Calculate weighted vulnerability score
  const vulnerabilityScore = Object.keys(weights).reduce((score, factor) =>
    score + (weights[factor] * factors[factor]), 0
  );

  // Determine category and generate recommendations
  const category = categorizeVulnerability(vulnerabilityScore);
  const recommendations = generateInterventions(factors, vulnerabilityScore);

  return {
    score: Math.round(vulnerabilityScore * 100),
    category,
    factors: Object.keys(factors).reduce((obj, key) => {
      obj[key] = Math.round(factors[key] * 100);
      return obj;
    }, {}),
    criticalFactors: identifyCriticalFactors(factors),
    recommendations,
    interventionPriority: calculateInterventionPriority(vulnerabilityScore, gridCell.population)
  };
}

/**
 * Analyze vulnerability patterns across a city
 * @param {Array} gridAnalysis - Grid cells with access analysis
 * @param {Object} cityData - City information
 * @param {Object} climate - Climate data
 * @returns {Object} City-wide vulnerability analysis
 */
export function analyzeCityVulnerability(gridAnalysis, cityData, climate) {
  // Calculate vulnerability for each grid cell
  const vulnerabilityMap = gridAnalysis.map(cell => ({
    ...cell,
    vulnerability: calculateVulnerabilityIndex(cell, [], climate)
  }));

  // Identify hotspots (clusters of high vulnerability)
  const hotspots = identifyVulnerabilityHotspots(vulnerabilityMap);

  // Calculate city-wide statistics
  const statistics = calculateVulnerabilityStatistics(vulnerabilityMap);

  // Generate city-level interventions
  const interventions = generateCityInterventions(hotspots, statistics);

  return {
    vulnerabilityMap,
    hotspots,
    statistics,
    interventions,
    riskLevel: determineOverallRisk(statistics),
    resilience: calculateResilience(vulnerabilityMap)
  };
}

/**
 * Create intervention recommendations based on vulnerability
 * @param {Object} vulnerabilityAnalysis - Vulnerability assessment
 * @param {Object} resources - Available resources and constraints
 * @returns {Object} Prioritized intervention plan
 */
export function createInterventionPlan(vulnerabilityAnalysis, resources = {}) {
  const { budget = Infinity, timeframe = 12, constraints = [] } = resources;

  // Generate potential interventions
  const interventions = generateInterventionOptions(vulnerabilityAnalysis);

  // Score and rank interventions
  const rankedInterventions = rankInterventions(interventions, vulnerabilityAnalysis, resources);

  // Create phased implementation plan
  const implementationPlan = createImplementationPhases(rankedInterventions, budget, timeframe);

  return {
    interventions: rankedInterventions,
    phases: implementationPlan,
    totalCost: calculateTotalCost(implementationPlan),
    expectedImpact: estimateImpact(implementationPlan, vulnerabilityAnalysis),
    timeline: generateTimeline(implementationPlan, timeframe)
  };
}

// Vulnerability Factor Calculations

function calculateFoodAccessVulnerability(gridCell) {
  if (!gridCell) return 0.5;

  // Invert access score (low access = high vulnerability)
  const accessVulnerability = 1 - (gridCell.accessScore || 0) / 100;

  // Consider outlet diversity
  const diversityFactor = gridCell.healthyOutlets > 0 ?
    Math.max(0, 1 - (gridCell.healthyOutlets / 5)) : 1;

  return accessVulnerability * 0.7 + diversityFactor * 0.3;
}

function calculateEconomicVulnerability(demographics) {
  if (!demographics) return 0.5; // Default moderate vulnerability

  const factors = {
    povertyRate: demographics.povertyRate || 0.15,
    unemploymentRate: demographics.unemploymentRate || 0.05,
    medianIncome: demographics.medianIncome ?
      Math.max(0, 1 - (demographics.medianIncome / 75000)) : 0.5
  };

  return (factors.povertyRate * 0.4 +
    factors.unemploymentRate * 0.3 +
    factors.medianIncome * 0.3);
}

function calculateClimateVulnerability(climate) {
  if (!climate?.data) return 0.3; // Default low-moderate vulnerability

  const { T2M, PRECTOTCORR } = climate.data;
  const temp = T2M?.mean || 20;
  const precip = PRECTOTCORR?.mean || 2;

  // Temperature vulnerability (extreme heat or cold)
  const tempVulnerability = temp > 35 ? 0.9 :
    temp > 30 ? 0.6 :
      temp < 5 ? 0.7 :
        temp < 10 ? 0.4 : 0.2;

  // Precipitation vulnerability (drought or flood risk)
  const precipVulnerability = precip < 0.5 ? 0.8 :
    precip < 1 ? 0.5 :
      precip > 10 ? 0.6 :
        precip > 7 ? 0.4 : 0.2;

  // Combine climate factors
  return tempVulnerability * 0.6 + precipVulnerability * 0.4;
}

function calculateDemographicVulnerability(demographics) {
  if (!demographics) return 0.4; // Default moderate vulnerability

  const vulnerableGroups = {
    elderly: demographics.over65Rate || 0.15,
    children: demographics.under18Rate || 0.25,
    disabled: demographics.disabilityRate || 0.12,
    noVehicle: demographics.noVehicleRate || 0.10,
    singleParent: demographics.singleParentRate || 0.08
  };

  // Weight vulnerable populations
  return Object.values(vulnerableGroups).reduce((sum, rate) =>
    sum + rate, 0) / Object.keys(vulnerableGroups).length;
}

function calculateInfrastructureVulnerability(outlets, gridCell, climate) {
  let vulnerability = 0;

  // Transportation infrastructure
  const transitAccess = gridCell.transitStops || 0;
  vulnerability += transitAccess < 2 ? 0.3 : 0.1;

  // Storage infrastructure (critical in hot climates)
  if (climate?.data?.T2M?.mean > 30) {
    const coldStorage = outlets.filter(o => o.tags?.refrigerated).length;
    vulnerability += coldStorage === 0 ? 0.3 : 0.1;
  }

  // Market infrastructure
  const markets = outlets.filter(o => o.type === 'marketplace').length;
  vulnerability += markets === 0 ? 0.2 : 0;

  // Road quality (assumed from outlet density as proxy)
  const outletDensity = outlets.length / (gridCell.area || 1);
  vulnerability += outletDensity < 5 ? 0.2 : 0.1;

  return Math.min(vulnerability, 1);
}

// Categorization and Identification Functions

function categorizeVulnerability(score) {
  if (score >= 0.8) return 'CRITICAL';
  if (score >= 0.6) return 'HIGH';
  if (score >= 0.4) return 'MODERATE';
  if (score >= 0.2) return 'LOW';
  return 'MINIMAL';
}

function identifyCriticalFactors(factors) {
  return Object.entries(factors)
    .filter(([_, score]) => score >= 0.7)
    .map(([factor, score]) => ({
      factor,
      score: Math.round(score * 100),
      severity: score >= 0.85 ? 'CRITICAL' : 'HIGH'
    }))
    .sort((a, b) => b.score - a.score);
}

function calculateInterventionPriority(vulnerabilityScore, population) {
  const populationImpact = Math.min(population / 10000, 1);
  return vulnerabilityScore * 0.7 + populationImpact * 0.3;
}

// Intervention Generation Functions

function generateInterventions(factors, vulnerabilityScore) {
  const interventions = [];

  // Food access interventions
  if (factors.foodAccess > 0.7) {
    interventions.push({
      type: 'FOOD_ACCESS',
      priority: 'CRITICAL',
      action: 'Establish new food outlets or mobile markets',
      impact: 'HIGH',
      timeframe: '1-3 months',
      cost: 'MEDIUM'
    });
  }

  // Climate interventions
  if (factors.climate > 0.6) {
    interventions.push({
      type: 'CLIMATE_ADAPTATION',
      priority: 'HIGH',
      action: 'Install cooling infrastructure and climate-resilient storage',
      impact: 'HIGH',
      timeframe: '3-6 months',
      cost: 'HIGH'
    });
  }

  // Economic interventions
  if (factors.economic > 0.6) {
    interventions.push({
      type: 'ECONOMIC_SUPPORT',
      priority: 'HIGH',
      action: 'Implement food assistance programs and subsidies',
      impact: 'MEDIUM',
      timeframe: '1 month',
      cost: 'MEDIUM'
    });
  }

  // Infrastructure interventions
  if (factors.infrastructure > 0.5) {
    interventions.push({
      type: 'INFRASTRUCTURE',
      priority: 'MEDIUM',
      action: 'Improve transportation and storage facilities',
      impact: 'HIGH',
      timeframe: '6-12 months',
      cost: 'HIGH'
    });
  }

  return interventions;
}

// Hotspot Analysis Functions

function identifyVulnerabilityHotspots(vulnerabilityMap) {
  const threshold = 0.7; // 70% vulnerability threshold for hotspots
  const hotspotCells = vulnerabilityMap.filter(cell =>
    cell.vulnerability.score >= threshold * 100
  );

  // Cluster nearby hotspot cells
  const hotspots = clusterHotspots(hotspotCells);

  return hotspots.map(hotspot => ({
    ...hotspot,
    severity: calculateHotspotSeverity(hotspot),
    affectedPopulation: hotspot.cells.reduce((sum, c) => sum + (c.population || 0), 0),
    recommendations: generateHotspotInterventions(hotspot)
  }));
}

function clusterHotspots(hotspotCells) {
  const clusters = [];
  const visited = new Set();

  hotspotCells.forEach(cell => {
    if (visited.has(cell.id)) return;

    const cluster = {
      id: `hotspot_${clusters.length}`,
      cells: [],
      center: null,
      area: 0
    };

    // BFS to find connected vulnerable cells
    const queue = [cell];
    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(current.id)) continue;

      visited.add(current.id);
      cluster.cells.push(current);
      cluster.area += current.area || 1;

      // Find adjacent vulnerable cells
      const adjacent = hotspotCells.filter(c =>
        !visited.has(c.id) &&
        isAdjacent(c, current)
      );

      queue.push(...adjacent);
    }

    // Calculate cluster center
    cluster.center = calculateCenter(cluster.cells);
    clusters.push(cluster);
  });

  return clusters;
}

function isAdjacent(cell1, cell2) {
  const latDiff = Math.abs(cell1.center.lat - cell2.center.lat);
  const lngDiff = Math.abs(cell1.center.lng - cell2.center.lng);
  return latDiff < 0.011 && lngDiff < 0.011; // ~1km threshold
}

function calculateCenter(cells) {
  const avgLat = cells.reduce((sum, c) => sum + c.center.lat, 0) / cells.length;
  const avgLng = cells.reduce((sum, c) => sum + c.center.lng, 0) / cells.length;
  return { lat: avgLat, lng: avgLng };
}

function calculateHotspotSeverity(hotspot) {
  const avgVulnerability = hotspot.cells.reduce((sum, c) =>
    sum + c.vulnerability.score, 0) / hotspot.cells.length;

  if (avgVulnerability >= 85) return 'CRITICAL';
  if (avgVulnerability >= 75) return 'SEVERE';
  return 'HIGH';
}

function generateHotspotInterventions(hotspot) {
  const interventions = [];
  const avgFactors = calculateAverageFactors(hotspot.cells);

  if (avgFactors.foodAccess > 70) {
    interventions.push('Urgent: Establish emergency food distribution center');
  }
  if (avgFactors.climate > 60) {
    interventions.push('Install climate-controlled storage facilities');
  }
  if (avgFactors.economic > 60) {
    interventions.push('Deploy targeted food assistance programs');
  }

  return interventions;
}

function calculateAverageFactors(cells) {
  const totals = cells.reduce((acc, cell) => {
    Object.keys(cell.vulnerability.factors).forEach(factor => {
      acc[factor] = (acc[factor] || 0) + cell.vulnerability.factors[factor];
    });
    return acc;
  }, {});

  Object.keys(totals).forEach(factor => {
    totals[factor] = totals[factor] / cells.length;
  });

  return totals;
}

// Statistics and Analysis Functions

function calculateVulnerabilityStatistics(vulnerabilityMap) {
  const scores = vulnerabilityMap.map(c => c.vulnerability.score);
  const categories = vulnerabilityMap.reduce((acc, cell) => {
    const cat = cell.vulnerability.category;
    acc[cat] = (acc[cat] || 0) + 1;
    return acc;
  }, {});

  return {
    mean: scores.reduce((sum, s) => sum + s, 0) / scores.length,
    median: scores.sort((a, b) => a - b)[Math.floor(scores.length / 2)],
    max: Math.max(...scores),
    min: Math.min(...scores),
    distribution: categories,
    criticalAreas: vulnerabilityMap.filter(c => c.vulnerability.category === 'CRITICAL').length,
    affectedPopulation: vulnerabilityMap
      .filter(c => c.vulnerability.score >= 60)
      .reduce((sum, c) => sum + (c.population || 0), 0)
  };
}

function determineOverallRisk(statistics) {
  if (statistics.mean >= 70) return 'CRITICAL';
  if (statistics.mean >= 50) return 'HIGH';
  if (statistics.mean >= 30) return 'MODERATE';
  return 'LOW';
}

function calculateResilience(vulnerabilityMap) {
  const lowVulnerability = vulnerabilityMap.filter(c => c.vulnerability.score < 40).length;
  const total = vulnerabilityMap.length;

  const resilienceScore = (lowVulnerability / total) * 100;

  return {
    score: Math.round(resilienceScore),
    category: resilienceScore >= 70 ? 'HIGH' :
      resilienceScore >= 40 ? 'MODERATE' : 'LOW',
    strengths: identifyStrengths(vulnerabilityMap),
    improvementAreas: identifyImprovementAreas(vulnerabilityMap)
  };
}

function identifyStrengths(vulnerabilityMap) {
  const strengths = [];

  const goodAccess = vulnerabilityMap.filter(c =>
    c.vulnerability.factors.foodAccess < 30
  ).length / vulnerabilityMap.length;

  if (goodAccess > 0.5) {
    strengths.push('Strong food outlet coverage in many areas');
  }

  const lowClimateRisk = vulnerabilityMap.filter(c =>
    c.vulnerability.factors.climate < 30
  ).length / vulnerabilityMap.length;

  if (lowClimateRisk > 0.5) {
    strengths.push('Favorable climate conditions for food preservation');
  }

  return strengths;
}

function identifyImprovementAreas(vulnerabilityMap) {
  const areas = [];

  const poorAccess = vulnerabilityMap.filter(c =>
    c.vulnerability.factors.foodAccess > 70
  ).length;

  if (poorAccess > vulnerabilityMap.length * 0.2) {
    areas.push('Expand food outlet coverage in underserved areas');
  }

  const highEconomic = vulnerabilityMap.filter(c =>
    c.vulnerability.factors.economic > 60
  ).length;

  if (highEconomic > vulnerabilityMap.length * 0.3) {
    areas.push('Address economic barriers to food access');
  }

  return areas;
}

// City-level Intervention Functions

function generateCityInterventions(hotspots, statistics) {
  const interventions = [];

  // Priority 1: Address critical hotspots
  if (hotspots.length > 0) {
    interventions.push({
      priority: 1,
      type: 'HOTSPOT_INTERVENTION',
      description: `Target ${hotspots.length} vulnerability hotspots affecting ${
        hotspots.reduce((sum, h) => sum + h.affectedPopulation, 0).toLocaleString()
      } people`,
      actions: hotspots.slice(0, 3).map(h => ({
        location: h.center,
        severity: h.severity,
        intervention: h.recommendations[0]
      }))
    });
  }

  // Priority 2: System-wide improvements
  if (statistics.mean > 50) {
    interventions.push({
      priority: 2,
      type: 'SYSTEMIC_IMPROVEMENT',
      description: 'Implement city-wide food security improvements',
      actions: [
        'Expand public transportation to food outlets',
        'Establish community food hubs in vulnerable areas',
        'Create urban farming initiatives'
      ]
    });
  }

  return interventions;
}

// Implementation Planning Functions

function generateInterventionOptions(vulnerabilityAnalysis) {
  const options = [];

  // Generate options based on vulnerability factors
  if (vulnerabilityAnalysis.factors.foodAccess > 60) {
    options.push(
      {
        id: 'new_outlet',
        type: 'NEW_OUTLET',
        description: 'Establish new food outlet',
        cost: 50000,
        impact: 30,
        timeMonths: 3
      },
      {
        id: 'mobile_market',
        type: 'MOBILE_MARKET',
        description: 'Deploy mobile food market',
        cost: 20000,
        impact: 20,
        timeMonths: 1
      }
    );
  }

  if (vulnerabilityAnalysis.factors.climate > 50) {
    options.push({
      id: 'cold_storage',
      type: 'INFRASTRUCTURE',
      description: 'Install refrigerated storage',
      cost: 30000,
      impact: 25,
      timeMonths: 2
    });
  }

  return options;
}

function rankInterventions(interventions, vulnerabilityAnalysis, resources) {
  return interventions.map(intervention => {
    // Calculate cost-benefit ratio
    const costBenefit = intervention.impact / (intervention.cost / 10000);

    // Urgency based on vulnerability
    const urgency = vulnerabilityAnalysis.score / 100;

    // Feasibility based on resources
    const feasibility = intervention.cost <= resources.budget ? 1 : 0.5;

    // Combined score
    const score = (costBenefit * 0.4 + urgency * 0.3 + feasibility * 0.3);

    return {
      ...intervention,
      score,
      rank: null
    };
  }).sort((a, b) => b.score - a.score)
    .map((int, index) => ({ ...int, rank: index + 1 }));
}

function createImplementationPhases(interventions, budget, timeframe) {
  const phases = [];
  let remainingBudget = budget;
  let currentMonth = 0;

  // Phase 1: Quick wins (1-3 months)
  const quickWins = interventions.filter(i =>
    i.timeMonths <= 3 && i.cost <= remainingBudget
  );
  if (quickWins.length > 0) {
    phases.push({
      phase: 1,
      name: 'Quick Wins',
      months: '1-3',
      interventions: quickWins.slice(0, 3),
      cost: quickWins.slice(0, 3).reduce((sum, i) => sum + i.cost, 0)
    });
    remainingBudget -= phases[0].cost;
    currentMonth = 3;
  }

  // Phase 2: Core improvements (4-6 months)
  if (currentMonth < timeframe && remainingBudget > 0) {
    const coreImprovements = interventions.filter(i =>
      i.timeMonths > 3 && i.timeMonths <= 6 &&
      i.cost <= remainingBudget && !phases[0]?.interventions.includes(i)
    );

    if (coreImprovements.length > 0) {
      phases.push({
        phase: 2,
        name: 'Core Improvements',
        months: '4-6',
        interventions: coreImprovements.slice(0, 2),
        cost: coreImprovements.slice(0, 2).reduce((sum, i) => sum + i.cost, 0)
      });
    }
  }

  return phases;
}

function calculateTotalCost(phases) {
  return phases.reduce((total, phase) => total + phase.cost, 0);
}

function estimateImpact(phases, vulnerabilityAnalysis) {
  const totalImpact = phases.reduce((impact, phase) =>
    impact + phase.interventions.reduce((sum, i) => sum + i.impact, 0), 0
  );

  const currentScore = vulnerabilityAnalysis.score;
  const improvedScore = Math.max(0, currentScore - totalImpact);

  return {
    currentVulnerability: currentScore,
    projectedVulnerability: improvedScore,
    improvement: currentScore - improvedScore,
    percentageReduction: ((currentScore - improvedScore) / currentScore) * 100
  };
}

function generateTimeline(phases, totalMonths) {
  const timeline = [];

  phases.forEach(phase => {
    phase.interventions.forEach(intervention => {
      timeline.push({
        month: parseInt(phase.months.split('-')[0]),
        intervention: intervention.description,
        cost: intervention.cost,
        impact: intervention.impact
      });
    });
  });

  return timeline;
}

// eslint-disable-next-line import/no-anonymous-default-export
export default {
  calculateVulnerabilityIndex,
  analyzeCityVulnerability,
  createInterventionPlan
};